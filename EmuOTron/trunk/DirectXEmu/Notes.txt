
Put APU in its own class, hook into writes (and reads?) on APU registers,
pass in frame number and cycles when registers are changed and run the
APU in catch up, will have to run it once at the end of the frame, gives
and idea of how I will eventually swap PPU to cycle accurate catch up
version.



DONE DONE DONE
		Replace this.Memory[] with a class using index operaterator
		allowing me to tap into every read/write for breakpoints,
		and possibly simplify bank switching, can also be
		implimented for the PPU mem

		All memory could be split into 1kb blocks and the
		memory reader would select the appropriate one to read/
		write from/to banks would be in banks[0xXX][0x400] finally
		with an array mapping the current memory memMap[0x3F]
		memMap[mem address >> 0xA] = bank number
		eg. to read 0x6658
		val = banks[memMap[0x6658 >> 0xA]][0x6658 & 0x3FF]

		Mirroring would remain done in the same fashion except for
		extremely large areas like PPU >0x3FFF

		If a mapper requires more grainular banks I could
		expose the banks and code specifically for the mapper
DONE DONE DONE

 